uint32_t key_pressed_tick = 0;
uint16_t column_pressed = 0;

uint32_t debounce_tick = 0;
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if ((debounce_tick + 200) > HAL_GetTick()) {
    return;
  }
  debounce_tick = HAL_GetTick();
  key_pressed_tick = HAL_GetTick();
  column_pressed = GPIO_Pin;
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    // Verificamos que la interrupción provenga de USART2
    if (huart->Instance == USART2)
    {
      ring_buffer_write(&rb, rx_data);

      process_command(&rb);

      // Reiniciar la recepción para seguir recibiendo datos
      HAL_UART_Receive_IT(&huart2, &rx_data, 1);
    }
}

// Variable global para almacenar el estado actual de la puerta
uint8_t current_door_state;

const char* watch_state() {
  switch(current_door_state)
  {
    case 1:
      return "Door is OPEN";
    case 0:
      return "Door is CLOSE";
    default:
      return "Unknown state";
  }
}

void process_command(ring_buffer_t *rb) {
  uint8_t data;
  uint8_t buffer_cleared = 0; // Flag para indicar si el búfer ha sido borrado

  // Recorremos el búfer mientras haya datos disponibles
  while (ring_buffer_read(rb, &data)) {
      switch (data) {
          case 'A':
              HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
              current_door_state = 1; // Actualizamos el estado actual
              HAL_UART_Transmit(&huart2, (uint8_t *)&data, 15, 1000);

              break;

          case 'C':
              HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
              current_door_state = 0; // Actualizamos el estado actual
              HAL_UART_Transmit(&huart2, (uint8_t *)&data, 15, 1000);
              break;

          case '1': {
              const char *message = watch_state();
              HAL_UART_Transmit(&huart2, (uint8_t *)message, strlen(message), 100);
              break;
          }

          case '0':
              // Si se encuentra un '0', borramos el búfer
              ring_buffer_reset(rb);
              buffer_cleared = 1; // Marcamos que el búfer ha sido borrado
              break;

          default:
              break;
      }

      // Si el búfer ha sido borrado, salimos del bucle
      if (buffer_cleared) {
          break;
      }
  }
}




keypad_init();
  ring_buffer_init(&rb, buffer_memory, BUFFER_CAPACITY);

  HAL_UART_Receive_IT(&huart2, &rx_data, 1);
  HAL_UART_Transmit(&huart2, (uint8_t *)"Hello, World!\r\n", 15, 1000);

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    if (column_pressed != 0 && (key_pressed_tick + 5) < HAL_GetTick() ) {
      uint8_t key = keypad_scan(column_pressed);
      ring_buffer_write(&rb, key);
      column_pressed = 0;
      process_command(&rb);
    }
    /* USER CODE END WHILE */


    /* USER CODE BEGIN 3 */
  }
